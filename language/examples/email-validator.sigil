âŸ¦ Email Validation Example

Demonstrates string operations, pattern guards, and validation logic.

This example validates email addresses using basic rules:
- Must contain exactly one @ symbol
- Local part (before @) must not be empty
- Domain part (after @) must contain at least one dot
- Domain must not start or end with a dot
- Total length must be reasonable

Note: This is a simplified validator for demonstration purposes.
Production email validation is more complex (RFC 5322).
âŸ§

âŸ¦ Email components after splitting âŸ§
t EmailParts={local:ğ•Š,domain:ğ•Š}

âŸ¦ Result type for validation âŸ§
t ValidationResult=Valid|Invalid(ğ•Š)

e console

i stdlibâ‹…string

âŸ¦ Helper: Count occurrences of character in string âŸ§
Î»count_char(char:ğ•Š,str:ğ•Š)â†’â„¤=count_helper(0,char,0,str)

Î»count_helper(acc:â„¤,char:ğ•Š,idx:â„¤,str:ğ•Š)â†’â„¤â‰¡idx<#str{
  âŠ¤ â†’ count_helper(acc+â‰¡stdlibâ‹…string.char_at(idx,str)=char{âŠ¤â†’1|âŠ¥â†’0},char,idx+1,str) |
  âŠ¥ â†’ acc
}

âŸ¦ Helper: Extract local and domain from split result âŸ§
Î»extract_parts(parts:[ğ•Š])â†’EmailPartsâ‰¡#parts=2{
  âŠ¤ â†’ extract_two_parts(parts) |
  âŠ¥ â†’ {local:"",domain:""}
}

Î»extract_two_parts(parts:[ğ•Š])â†’EmailPartsâ‰¡parts{
  [local,domain] â†’ {local:local,domain:domain} |
  _ â†’ {local:"",domain:""}
}

âŸ¦ Helper: Format validation result for display âŸ§
Î»format_result(email:ğ•Š,result:ValidationResult)â†’ğ•Šâ‰¡result{
  Valid â†’ "âœ“ '"++email++"' is valid" |
  Invalid(reason) â†’ "âœ— '"++email++"': "++reason
}

âŸ¦ Main - Demonstrate email validation âŸ§
Î»main()â†’!IO ğ•Œ={
  l _=(console.log("=== Email Validator ===\n"):ğ•Œ);

  âŸ¦ Valid emails âŸ§
  l _=(console.log("Valid examples:"):ğ•Œ);
  l _=(console.log(format_result("user@example.com",validate_email("user@example.com"))):ğ•Œ);
  l _=(console.log(format_result("alice.bob@mail.co.uk",validate_email("alice.bob@mail.co.uk"))):ğ•Œ);
  l _=(console.log(format_result("test123@domain.org",validate_email("test123@domain.org"))):ğ•Œ);

  l _=(console.log("\nInvalid examples:"):ğ•Œ);

  âŸ¦ Missing @ âŸ§
  l _=(console.log(format_result("userexample.com",validate_email("userexample.com"))):ğ•Œ);

  âŸ¦ Multiple @ âŸ§
  l _=(console.log(format_result("user@@example.com",validate_email("user@@example.com"))):ğ•Œ);

  âŸ¦ Empty local âŸ§
  l _=(console.log(format_result("@example.com",validate_email("@example.com"))):ğ•Œ);

  âŸ¦ Empty domain âŸ§
  l _=(console.log(format_result("user@",validate_email("user@"))):ğ•Œ);

  âŸ¦ No dot in domain âŸ§
  l _=(console.log(format_result("user@domain",validate_email("user@domain"))):ğ•Œ);

  âŸ¦ Domain starts with dot âŸ§
  l _=(console.log(format_result("user@.example.com",validate_email("user@.example.com"))):ğ•Œ);

  âŸ¦ Domain ends with dot âŸ§
  l _=(console.log(format_result("user@example.com.",validate_email("user@example.com."))):ğ•Œ);

  âŸ¦ Local starts with dot âŸ§
  l _=(console.log(format_result(".user@example.com",validate_email(".user@example.com"))):ğ•Œ);

  âŸ¦ Consecutive dots in local âŸ§
  l _=(console.log(format_result("user..name@example.com",validate_email("user..name@example.com"))):ğ•Œ);

  âŸ¦ Empty email âŸ§
  console.log(format_result("",validate_email("")))
}

âŸ¦ Helper: Split email at @ symbol âŸ§
Î»split_at(email:ğ•Š)â†’EmailParts=extract_parts(stdlibâ‹…string.split(email,"@"))

âŸ¦ Validate domain part (after @) âŸ§
Î»validate_domain(domain:ğ•Š)â†’ValidationResult=validate_domain_checks(domain,#domain)

Î»validate_domain_checks(domain:ğ•Š,len:â„¤)â†’ValidationResultâ‰¡len=0{
  âŠ¤ â†’ Invalid("Domain cannot be empty") |
  âŠ¥ â†’ â‰¡len>255{
    âŠ¤ â†’ Invalid("Domain too long (max 255 characters)") |
    âŠ¥ â†’ â‰¡stdlibâ‹…string.index_of(domain,".")<0{
      âŠ¤ â†’ Invalid("Domain must contain at least one dot") |
      âŠ¥ â†’ â‰¡stdlibâ‹…string.starts_with(domain,"."){
        âŠ¤ â†’ Invalid("Domain cannot start with dot") |
        âŠ¥ â†’ â‰¡stdlibâ‹…string.ends_with(domain,"."){
          âŠ¤ â†’ Invalid("Domain cannot end with dot") |
          âŠ¥ â†’ â‰¡stdlibâ‹…string.index_of(domain,"..")â‰¥0{
            âŠ¤ â†’ Invalid("Domain cannot contain consecutive dots") |
            âŠ¥ â†’ Valid()
          }
        }
      }
    }
  }
}

âŸ¦ Main email validation function - exported for testing âŸ§
Î»validate_email(email:ğ•Š)â†’ValidationResult=validate_email_with_parts(email,split_at(email))

âŸ¦ Validate email parts after splitting âŸ§
Î»validate_email_parts(parts:EmailParts)â†’ValidationResultâ‰¡validate_local(parts.local){
  Invalid(msg) â†’ Invalid(msg) |
  Valid â†’ validate_domain(parts.domain)
}

Î»validate_email_with_parts(email:ğ•Š,parts:EmailParts)â†’ValidationResultâ‰¡#email=0{
  âŠ¤ â†’ Invalid("Email cannot be empty") |
  âŠ¥ â†’ â‰¡#email>320{
    âŠ¤ â†’ Invalid("Email too long (max 320 characters)") |
    âŠ¥ â†’ â‰¡#parts.local=0âˆ§#parts.domain=0{
      âŠ¤ â†’ Invalid("Email must contain exactly one @ symbol") |
      âŠ¥ â†’ validate_email_parts(parts)
    }
  }
}

âŸ¦ Validate local part (before @) âŸ§
Î»validate_local(local:ğ•Š)â†’ValidationResult=validate_local_checks(#local,local)

Î»validate_local_checks(len:â„¤,local:ğ•Š)â†’ValidationResultâ‰¡len=0{
  âŠ¤ â†’ Invalid("Local part cannot be empty") |
  âŠ¥ â†’ â‰¡len>64{
    âŠ¤ â†’ Invalid("Local part too long (max 64 characters)") |
    âŠ¥ â†’ â‰¡stdlibâ‹…string.starts_with(local,"."){
      âŠ¤ â†’ Invalid("Local part cannot start with dot") |
      âŠ¥ â†’ â‰¡stdlibâ‹…string.ends_with(local,"."){
        âŠ¤ â†’ Invalid("Local part cannot end with dot") |
        âŠ¥ â†’ â‰¡stdlibâ‹…string.index_of(local,"..")â‰¥0{
          âŠ¤ â†’ Invalid("Local part cannot contain consecutive dots") |
          âŠ¥ â†’ Valid()
        }
      }
    }
  }
}
