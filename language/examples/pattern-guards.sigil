âŸ¦ Pattern Guards - Conditional Pattern Matching

Pattern guards extend Sigil's pattern matching with conditional checks.
They allow you to test conditions on pattern bindings before accepting a match.

Syntax: pattern when boolean_expr â†’ body

The guard expression:
- Is evaluated AFTER pattern bindings are established
- Has access to all bindings from the pattern
- Must have type ğ”¹ (boolean)
- If false, matching continues to the next arm

This feature was added to enable clean state machine implementations
(like the markdown parser in stdlibâ‹…markdown).
âŸ§

âŸ¦ Type Definitions âŸ§
t Action=Increment|Decrement|Reset
t Color=Red|Green|Blue
t Point={x:â„¤,y:â„¤}
t Result=Ok(â„¤)|Err(ğ•Š)
t State={mode:ğ•Š,count:â„¤}
t User={name:ğ•Š,age:â„¤}

e console

i stdlibâ‹…string

âŸ¦ Example 1: Range Checking

Without guards, you'd need nested match expressions.
With guards, you can express ranges cleanly.
âŸ§

Î»classifyNumber(n:â„¤)â†’ğ•Šâ‰¡n{
  x when x>1000 â†’ "huge" |
  x when x>100 â†’ "large" |
  x when x>10 â†’ "medium" |
  x when x>0 â†’ "small" |
  0 â†’ "zero" |
  _ â†’ "negative"
}

âŸ¦ Example 5: Complex Conditions

Guards can use any boolean expression, including
conjunction (âˆ§), disjunction (âˆ¨), and comparisons.
âŸ§

Î»classifyPoint(p:Point)â†’ğ•Šâ‰¡p.x{
  x when x=0âˆ§p.y=0 â†’ "origin" |
  x when x=0 â†’ "on y-axis" |
  _ when p.y=0 â†’ "on x-axis" |
  x when x=p.y â†’ "on diagonal y=x" |
  x when x=-p.y â†’ "on diagonal y=-x" |
  x when x>0âˆ§p.y>0 â†’ "quadrant I" |
  x when x<0âˆ§p.y>0 â†’ "quadrant II" |
  x when x<0âˆ§p.y<0 â†’ "quadrant III" |
  _ â†’ "quadrant IV"
}

âŸ¦ Example 8: Backward Compatibility

Patterns without guards work exactly as before.
Guards are purely additive.
âŸ§

Î»colorToHex(color:Color)â†’ğ•Šâ‰¡color{
  Red â†’ "#FF0000" |
  Green â†’ "#00FF00" |
  Blue â†’ "#0000FF"
}

âŸ¦ Example 7: List Processing

Combine list patterns with guards for powerful
conditional list processing.
âŸ§

Î»findFirstPositive(list:[â„¤])â†’ğ•Šâ‰¡list{
  [] â†’ "empty list" |
  [x,.rest] when x>0 â†’ "first positive: "++stdlibâ‹…string.int_to_string(x) |
  [_,.xs] â†’ findFirstPositive(xs)
}

âŸ¦ Demo - Run examples âŸ§

Î»main()â†’â„¤={
  l _=(console.log("=== Range Checking ==="):ğ•Œ);
  l _=(console.log(classifyNumber(5000)):ğ•Œ);
  l _=(console.log(classifyNumber(50)):ğ•Œ);
  l _=(console.log(classifyNumber(5)):ğ•Œ);
  l _=(console.log(classifyNumber(-5)):ğ•Œ);

  l _=(console.log("\n=== User Validation ==="):ğ•Œ);
  l _=(console.log(validateUser({name:"Alice",age:30})):ğ•Œ);
  l _=(console.log(validateUser({name:"",age:25})):ğ•Œ);
  l _=(console.log(validateUser({name:"Bob",age:-5})):ğ•Œ);

  l _=(console.log("\n=== Result Processing ==="):ğ•Œ);
  l _=(console.log(processResult(Ok(150))):ğ•Œ);
  l _=(console.log(processResult(Ok(5))):ğ•Œ);
  l _=(console.log(processResult(Err("timeout"))):ğ•Œ);

  l _=(console.log("\n=== Priority Tasks ==="):ğ•Œ);
  l _=(console.log(prioritizeTask(5,âŠ¤)):ğ•Œ);
  l _=(console.log(prioritizeTask(5,âŠ¥)):ğ•Œ);
  l _=(console.log(prioritizeTask(9,âŠ¥)):ğ•Œ);

  l _=(console.log("\n=== Point Classification ==="):ğ•Œ);
  l _=(console.log(classifyPoint({x:0,y:0})):ğ•Œ);
  l _=(console.log(classifyPoint({x:5,y:5})):ğ•Œ);
  l _=(console.log(classifyPoint({x:3,y:7})):ğ•Œ);

  l _=(console.log("\n=== Color Conversion ==="):ğ•Œ);
  l _=(console.log(colorToHex(Red())):ğ•Œ);

  0
}

âŸ¦ Example 4: Fall-through Behavior

When a guard fails, matching continues to the next arm.
This enables priority-based matching.
âŸ§

Î»prioritizeTask(priority:â„¤,urgent:ğ”¹)â†’ğ•Šâ‰¡priority{
  p when urgent â†’ "URGENT (priority "++stdlibâ‹…string.int_to_string(p)++")" |
  p when p>7 â†’ "High priority" |
  p when p>3 â†’ "Medium priority" |
  _ â†’ "Low priority"
}

âŸ¦ Example 3: Conditional Unpacking

Match on structure, then check additional conditions
on the unpacked values.
âŸ§

Î»processResult(r:Result)â†’ğ•Šâ‰¡r{
  Ok(n) when n>100 â†’ "Big success: "++stdlibâ‹…string.int_to_string(n) |
  Ok(n) when n>0 â†’ "Success: "++stdlibâ‹…string.int_to_string(n) |
  Ok(n) â†’ "Success with zero or negative" |
  Err(msg) when #msg>0 â†’ "Error: "++msg |
  Err(_) â†’ "Unknown error"
}

âŸ¦ Example 6: State Machines

Pattern guards shine in state machine implementations.
Match on state structure, guard on input conditions.
âŸ§

Î»stateTransition(action:Action,state:State)â†’Stateâ‰¡action{
  Increment when state.count<100 â†’ {mode:state.mode,count:state.count+1} |
  Increment â†’ {mode:"maxed",count:100} |
  Decrement when state.count>0 â†’ {mode:state.mode,count:state.count-1} |
  Decrement â†’ {mode:"empty",count:0} |
  Reset â†’ {mode:"normal",count:0}
}

âŸ¦ Example 2: Validating Data

Guards are perfect for validation logic where you match
on structure but need to check constraints.
âŸ§

Î»validateUser(u:User)â†’ğ•Šâ‰¡u.age{
  age when age<0 â†’ "Invalid: negative age" |
  age when age>150 â†’ "Invalid: age too high" |
  _ when #u.name=0 â†’ "Invalid: empty name" |
  _ â†’ "Valid user: "++u.name
}

âŸ¦ Design Principles

1. ONE CANONICAL FORM: Guards extend â‰¡, they don't replace it
2. TYPE SAFE: Guards must be boolean (checked at compile time)
3. EXPLICIT: The `when` keyword makes intent clear
4. PREDICTABLE: Evaluation order is top-to-bottom

This fits Sigil's philosophy: add features only when they make
complex code SIMPLER, not just different.
âŸ§
