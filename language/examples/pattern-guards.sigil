‚ü¶ Pattern Guards - Conditional Pattern Matching

Pattern guards extend Sigil's pattern matching with conditional checks.
They allow you to test conditions on pattern bindings before accepting a match.

Syntax: pattern when boolean_expr ‚Üí body

The guard expression:
- Is evaluated AFTER pattern bindings are established
- Has access to all bindings from the pattern
- Must have type ùîπ (boolean)
- If false, matching continues to the next arm

This feature was added to enable clean state machine implementations
(like the markdown parser in stdlib‚ãÖmarkdown).
‚üß

e console

‚ü¶ Example 1: Range Checking

Without guards, you'd need nested match expressions.
With guards, you can express ranges cleanly.
‚üß

ŒªclassifyNumber(n:‚Ñ§)‚Üíùïä‚â°n{
  x when x>1000 ‚Üí "huge" |
  x when x>100 ‚Üí "large" |
  x when x>10 ‚Üí "medium" |
  x when x>0 ‚Üí "small" |
  0 ‚Üí "zero" |
  _ ‚Üí "negative"
}

‚ü¶ Example 2: Validating Data

Guards are perfect for validation logic where you match
on structure but need to check constraints.
‚üß

t User={name:ùïä,age:‚Ñ§}

ŒªvalidateUser(u:User)‚Üíùïä‚â°u{
  {name,age} when age<0 ‚Üí "Invalid: negative age" |
  {name,age} when age>150 ‚Üí "Invalid: age too high" |
  {name,..} when #name=0 ‚Üí "Invalid: empty name" |
  {name,age} ‚Üí "Valid user: "++name
}

‚ü¶ Example 3: Conditional Unpacking

Match on structure, then check additional conditions
on the unpacked values.
‚üß

t Result=Ok(‚Ñ§)|Err(ùïä)

ŒªprocessResult(r:Result)‚Üíùïä‚â°r{
  Ok(n) when n>100 ‚Üí "Big success: "++stdlib‚ãÖstring_ops.int_to_string(n) |
  Ok(n) when n>0 ‚Üí "Success: "++stdlib‚ãÖstring_ops.int_to_string(n) |
  Ok(n) ‚Üí "Success with zero or negative" |
  Err(msg) when #msg>0 ‚Üí "Error: "++msg |
  Err(_) ‚Üí "Unknown error"
}

‚ü¶ Example 4: Fall-through Behavior

When a guard fails, matching continues to the next arm.
This enables priority-based matching.
‚üß

ŒªprioritizeTask(priority:‚Ñ§,urgent:ùîπ)‚Üíùïä‚â°priority{
  p when urgent ‚Üí "URGENT (priority "++stdlib‚ãÖstring_ops.int_to_string(p)++")" |
  p when p>7 ‚Üí "High priority" |
  p when p>3 ‚Üí "Medium priority" |
  _ ‚Üí "Low priority"
}

‚ü¶ Example 5: Complex Conditions

Guards can use any boolean expression, including
conjunction (‚àß), disjunction (‚à®), and comparisons.
‚üß

t Point={x:‚Ñ§,y:‚Ñ§}

ŒªclassifyPoint(p:Point)‚Üíùïä‚â°p{
  {x,y} when x=0‚àßy=0 ‚Üí "origin" |
  {x,y} when x=0 ‚Üí "on y-axis" |
  {x,y} when y=0 ‚Üí "on x-axis" |
  {x,y} when x=y ‚Üí "on diagonal y=x" |
  {x,y} when x=-y ‚Üí "on diagonal y=-x" |
  {x,y} when x>0‚àßy>0 ‚Üí "quadrant I" |
  {x,y} when x<0‚àßy>0 ‚Üí "quadrant II" |
  {x,y} when x<0‚àßy<0 ‚Üí "quadrant III" |
  _ ‚Üí "quadrant IV"
}

‚ü¶ Example 6: State Machines

Pattern guards shine in state machine implementations.
Match on state structure, guard on input conditions.
‚üß

t State={mode:ùïä,count:‚Ñ§}
t Action=Increment|Decrement|Reset

ŒªstateTransition(state:State,action:Action)‚ÜíState‚â°action{
  Increment when state.count<100 ‚Üí {mode:state.mode,count:state.count+1} |
  Increment ‚Üí {mode:"maxed",count:100} |
  Decrement when state.count>0 ‚Üí {mode:state.mode,count:state.count-1} |
  Decrement ‚Üí {mode:"empty",count:0} |
  Reset ‚Üí {mode:"normal",count:0}
}

‚ü¶ Example 7: List Processing

Combine list patterns with guards for powerful
conditional list processing.
‚üß

ŒªfindFirstPositive(list:[‚Ñ§])‚Üíùïä‚â°list{
  [] ‚Üí "empty list" |
  [x,._] when x>0 ‚Üí "first positive: "++stdlib‚ãÖstring_ops.int_to_string(x) |
  [_,.xs] ‚Üí findFirstPositive(xs)
}

‚ü¶ Example 8: Backward Compatibility

Patterns without guards work exactly as before.
Guards are purely additive.
‚üß

t Color=Red|Green|Blue

ŒªcolorToHex(c:Color)‚Üíùïä‚â°c{
  Red ‚Üí "#FF0000" |
  Green ‚Üí "#00FF00" |
  Blue ‚Üí "#0000FF"
}

‚ü¶ Design Principles

1. ONE CANONICAL FORM: Guards extend ‚â°, they don't replace it
2. TYPE SAFE: Guards must be boolean (checked at compile time)
3. EXPLICIT: The `when` keyword makes intent clear
4. PREDICTABLE: Evaluation order is top-to-bottom

This fits Sigil's philosophy: add features only when they make
complex code SIMPLER, not just different.
‚üß

‚ü¶ Demo - Run examples ‚üß

Œªmain()‚Üí‚Ñ§‚â°{
  l _=console.log("=== Range Checking ===");
  l _=console.log(classifyNumber(5000));
  l _=console.log(classifyNumber(50));
  l _=console.log(classifyNumber(5));
  l _=console.log(classifyNumber(-5));

  l _=console.log("\n=== User Validation ===");
  l _=console.log(validateUser({name:"Alice",age:30}));
  l _=console.log(validateUser({name:"",age:25}));
  l _=console.log(validateUser({name:"Bob",age:-5}));

  l _=console.log("\n=== Result Processing ===");
  l _=console.log(processResult(Ok(150)));
  l _=console.log(processResult(Ok(5)));
  l _=console.log(processResult(Err("timeout")));

  l _=console.log("\n=== Priority Tasks ===");
  l _=console.log(prioritizeTask(5,‚ä§));
  l _=console.log(prioritizeTask(5,‚ä•));
  l _=console.log(prioritizeTask(9,‚ä•));

  l _=console.log("\n=== Point Classification ===");
  l _=console.log(classifyPoint({x:0,y:0}));
  l _=console.log(classifyPoint({x:5,y:5}));
  l _=console.log(classifyPoint({x:3,y:7}));

  l _=console.log("\n=== Color Conversion ===");
  l _=console.log(colorToHex(Red()));

  0
}
