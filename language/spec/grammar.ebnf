(*(* Sigil Programming Language - Formal Grammar (EBNF) *)
(* Version: 1.0.0 *)
(* Last Updated: 2026-02-21 *)

(* ============================================================================ *)
(* DESIGN PRINCIPLE: Exactly ONE way to write each construct                   *)
(* - No optional syntax                                                         *)
(* - No syntactic sugar                                                         *)
(* - Canonical formatting enforced at parse time                                *)
(* ============================================================================ *)

(* ============================================================================ *)
(* PROGRAM STRUCTURE                                                            *)
(* ============================================================================ *)

Program = { TopLevelDecl } ;

TopLevelDecl = FunctionDecl
             | TypeDecl
             | ImportDecl
             | ConstDecl ;

(* ============================================================================ *)
(* IMPORTS                                                                      *)
(* ============================================================================ *)

ImportDecl = "i" , ModulePath ;
ModulePath = Identifier , { "â‹…" , Identifier } ;

(* Example: i stdlibâ‹…list_utils *)
(* Note: Namespace imports only - no selective imports, no aliasing *)

(* ============================================================================ *)
(* TYPE DECLARATIONS                                                            *)
(* ============================================================================ *)

TypeDecl = "t" , TypeName , [ TypeParams ] , "=" , TypeDef ;

TypeName = UpperIdentifier ;
TypeParams = "[" , TypeParam , { "," , TypeParam } , "]" ;
TypeParam = UpperIdentifier ;

TypeDef = SumType | ProductType | TypeAlias ;

(* Sum Types (tagged unions) *)
SumType = Variant , { "|" , Variant } ;
Variant = UpperIdentifier , [ "(" , TypeList , ")" ] ;

(* Product Types (records/structs) *)
ProductType = "{" , FieldList , "}" ;
FieldList = Field , { "," , Field } ;
Field = Identifier , ":" , Type ;

(* Type Aliases *)
TypeAlias = Type ;

(* Examples:
   t Option[T]=Some(T)|None
   t Result[T,E]=Ok(T)|Err(E)
   t User={id:â„¤,name:ð•Š,email:ð•Š}
*)

(* ============================================================================ *)
(* TYPE EXPRESSIONS                                                             *)
(* ============================================================================ *)

Type = PrimitiveType
     | ListType
     | MapType
     | FunctionType
     | TypeConstructor
     | TypeVariable ;

PrimitiveType = "â„¤"     (* Int *)
              | "â„"     (* Float *)
              | "ð”¹"     (* Bool *)
              | "ð•Š"     (* String *)
              | "â„‚"     (* Char *)
              | "ð•Œ"     (* Unit *)
              ;

(* Shorthand aliases (deprecated in favor of Unicode) *)
(* I = Int, F = Float, B = Bool, S = String, C = Char, U = Unit *)

ListType = "[" , Type , "]" ;
MapType = "{" , Type , ":" , Type , "}" ;
FunctionType = "Î»(" , [ TypeList ] , ")" , "â†’" , Type ;
TypeConstructor = TypeName , [ "[" , TypeList , "]" ] ;
TypeVariable = UpperIdentifier ;
TypeList = Type , { "," , Type } ;

(* Examples:
   [â„¤]               List of integers
   {ð•Š:â„¤}             Map from string to int
   Î»(â„¤,â„¤)â†’â„¤          Function taking two ints, returning int
   Option[ð•Š]         Type constructor application
*)

(* ============================================================================ *)
(* FUNCTION DECLARATIONS                                                        *)
(* ============================================================================ *)

FunctionDecl = "Î»" , Identifier , "(" , [ ParamList ] , ")" , [ "â†’" , Type ] , "=" , Expr ;

ParamList = Param , { "," , Param } ;
Param = Identifier , [ ":" , Type ] ;

(* Examples:
   Î»add(x:â„¤,y:â„¤)â†’â„¤=x+y
   Î»fibonacci(n:â„¤)â†’â„¤â‰¡n{0â†’0|1â†’1|nâ†’fibonacci(n-1)+fibonacci(n-2)}
*)

(* ============================================================================ *)
(* CONSTANT DECLARATIONS                                                        *)
(* ============================================================================ *)

ConstDecl = "c" , Identifier , [ ":" , Type ] , "=" , Expr ;

(* Example: c PI:â„=3.14159 *)

(* ============================================================================ *)
(* EXPRESSIONS                                                                  *)
(* ============================================================================ *)

Expr = MatchExpr
     | LetExpr
     | LambdaExpr
     | IfExpr
     | BinaryExpr
     | UnaryExpr
     | ApplicationExpr
     | PrimaryExpr ;

(* ============================================================================ *)
(* PATTERN MATCHING (Primary Control Flow)                                     *)
(* ============================================================================ *)

MatchExpr = "â‰¡" , Expr , "{" , MatchArm , { "|" , MatchArm } , "}" ;
MatchArm = Pattern , "â†’" , Expr ;

Pattern = LiteralPattern
        | VariablePattern
        | WildcardPattern
        | ConstructorPattern
        | ListPattern
        | RecordPattern ;

LiteralPattern = Literal ;
VariablePattern = Identifier ;
WildcardPattern = "_" ;
ConstructorPattern = UpperIdentifier , [ "(" , PatternList , ")" ] ;
ListPattern = "[" , [ PatternList ] , "]" | "[" , Pattern , "," , ".." , Identifier , "]" ;
RecordPattern = "{" , FieldPatternList , "}" ;

PatternList = Pattern , { "," , Pattern } ;
FieldPatternList = FieldPattern , { "," , FieldPattern } ;
FieldPattern = Identifier , [ ":" , Pattern ] ;

(* Examples:
   â‰¡x{0â†’"zero"|1â†’"one"|_â†’"many"}
   â‰¡option{Some(v)â†’v|Noneâ†’0}
   â‰¡list{[]â†’0|[x,..]â†’x}
*)

(* ============================================================================ *)
(* LET BINDINGS                                                                 *)
(* ============================================================================ *)

LetExpr = "l" , Pattern , "=" , Expr , ";" , Expr ;

(* Example: l x=5;x+10 *)

(* ============================================================================ *)
(* LAMBDA EXPRESSIONS                                                           *)
(* ============================================================================ *)

LambdaExpr = "Î»" , [ ParamList ] , "â†’" , Expr ;

(* Example: Î»xâ†’x*2 *)

(* ============================================================================ *)
(* IF EXPRESSIONS (Syntactic Sugar for Match on Bool)                          *)
(* ============================================================================ *)

IfExpr = "â‰¡" , Expr , "{" , "âŠ¤" , "â†’" , Expr , "|" , "âŠ¥" , "â†’" , Expr , "}" ;

(* Note: Could be removed in favor of pure match, keeping for convenience *)
(* Example: â‰¡x>0{âŠ¤â†’"positive"|âŠ¥â†’"not positive"} *)

(* ============================================================================ *)
(* BINARY EXPRESSIONS                                                           *)
(* ============================================================================ *)

BinaryExpr = Expr , BinaryOp , Expr ;

BinaryOp = ArithOp | CompOp | LogicOp | PipeOp ;

ArithOp = "+" | "-" | "*" | "/" | "%" | "^" ;
CompOp = "=" | "â‰ " | "<" | ">" | "â‰¤" | "â‰¥" ;
LogicOp = "âˆ§" | "âˆ¨" ;
PipeOp = "|>" | ">>" | "<<" ;

(* Operator Precedence (highest to lowest):
   1. ^ (power)
   2. * / % (multiplication, division, modulo)
   3. + - (addition, subtraction)
   4. = â‰  < > â‰¤ â‰¥ (comparison)
   5. âˆ§ (logical and)
   6. âˆ¨ (logical or)
   7. |> >> << (pipelines and composition)
*)

(* ============================================================================ *)
(* UNARY EXPRESSIONS                                                            *)
(* ============================================================================ *)

UnaryExpr = UnaryOp , Expr ;
UnaryOp = "-" | "Â¬" ;

(* Examples: -5, Â¬true *)

(* ============================================================================ *)
(* FUNCTION APPLICATION                                                         *)
(* ============================================================================ *)

ApplicationExpr = Expr , "(" , [ ExprList ] , ")" ;
ExprList = Expr , { "," , Expr } ;

(* Example: fibonacci(5) *)

(* ============================================================================ *)
(* PRIMARY EXPRESSIONS                                                          *)
(* ============================================================================ *)

PrimaryExpr = Literal
            | Identifier
            | ListLiteral
            | RecordLiteral
            | TupleLiteral
            | "(" , Expr , ")" ;

(* ============================================================================ *)
(* LITERALS                                                                     *)
(* ============================================================================ *)

Literal = IntLiteral
        | FloatLiteral
        | BoolLiteral
        | StringLiteral
        | CharLiteral
        | UnitLiteral ;

IntLiteral = [ "-" ] , Digit , { Digit } ;
FloatLiteral = [ "-" ] , Digit , { Digit } , "." , Digit , { Digit } ;
BoolLiteral = "âŠ¤" | "âŠ¥" ;
StringLiteral = '"' , { StringChar } , '"' ;
CharLiteral = "'" , Char , "'" ;
UnitLiteral = "()" ;

(* ============================================================================ *)
(* COLLECTION LITERALS                                                          *)
(* ============================================================================ *)

ListLiteral = "[" , [ ExprList ] , "]" ;
RecordLiteral = "{" , FieldValueList , "}" ;
TupleLiteral = "(" , Expr , "," , ExprList , ")" ;

FieldValueList = FieldValue , { "," , FieldValue } ;
FieldValue = Identifier , ":" , Expr ;

(* Examples:
   [1,2,3]
   {id:42,name:"Alice",active:âŠ¤}
   (1,"hello",âŠ¤)
*)

(* ============================================================================ *)
(* IDENTIFIERS AND TOKENS                                                       *)
(* ============================================================================ *)

Identifier = LowerLetter , { Letter | Digit | "_" } ;
UpperIdentifier = UpperLetter , { Letter | Digit | "_" } ;

LowerLetter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m"
            | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;

UpperLetter = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M"
            | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;

Letter = LowerLetter | UpperLetter ;
Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
StringChar = ? any Unicode character except '"' and '\' ? | EscapeSeq ;
Char = ? any Unicode character except "'" and '\' ? | EscapeSeq ;
EscapeSeq = "\" , ( "n" | "t" | "r" | "\" | '"' | "'" ) ;

(* ============================================================================ *)
(* WHITESPACE AND COMMENTS                                                      *)
(* ============================================================================ *)

(* Whitespace: Space characters are significant only for token separation      *)
(* Newlines: No significance (unlike Python)                                    *)
(* Indentation: No significance (unlike Haskell)                                *)

Comment = "âŸ¦" , { ? any Unicode character except âŸ§ ? } , "âŸ§" ;

(* Note: Sigil uses ONLY âŸ¦ ... âŸ§ for comments (multi-line, block comments)     *)
(* No // or /* */ syntax - exactly ONE canonical comment form                   *)

(* ============================================================================ *)
(* FORMATTING RULES (ENFORCED AT PARSE TIME)                                   *)
(* ============================================================================ *)

(* CANONICAL FORMATTING RULES:
   1. NO spaces around operators: x+y not x + y
   2. NO spaces in function calls: f(x,y) not f(x, y)
   3. SINGLE space after commas in parameter lists: f(x,y) â†’ f(x, y)
   4. SINGLE space after ":" in type annotations: x:â„¤ not x : â„¤
   5. NO trailing whitespace on any line
   6. EXACTLY one newline at EOF
   7. Maximum one blank line between declarations
   8. NO line length limit (machines don't care)

   Violations of these rules result in PARSE ERROR, not warnings.
*)

(* ============================================================================ *)
(* STANDARD LIBRARY PRELUDE (Auto-imported)                                    *)
(* ============================================================================ *)

(* The following types and functions are automatically available:

   Types:
   - Option[T] = Some(T) | None
   - Result[T,E] = Ok(T) | Err(E)
   - List[T]
   - Map[K,V]
   - Set[T]

   Functions:
   - map: Î»map[T,U](fn:Î»(T)â†’U,list:[T])â†’[U]
   - filter: Î»filter[T](pred:Î»(T)â†’ð”¹,list:[T])â†’[T]
   - reduce: Î»reduce[T,U](fn:Î»(U,T)â†’U,init:U,list:[T])â†’U
   - print: Î»print(value:ð•Š)â†’ð•Œ!IO
   - panic: Î»panic(msg:ð•Š)â†’âˆ…

   See stdlib/prelude.sigil for full prelude.
*)

(* ============================================================================ *)
(* UNICODE SYMBOLS REFERENCE                                                    *)
(* ============================================================================ *)

(* Keywords:
   Î»  - lambda (function)
   â†’  - arrow (returns, maps-to)
   â‰¡  - equivalent (pattern match)

   Types:
   â„¤  - integers (Z from number theory)
   â„  - reals (R from number theory)
   ð”¹  - booleans (B double-struck)
   ð•Š  - strings (S double-struck)
   â„‚  - characters (C from complex numbers, repurposed)
   ð•Œ  - unit (U double-struck)

   Operators:
   â‰   - not equal
   â‰¤  - less than or equal
   â‰¥  - greater than or equal
   âˆ§  - logical and
   âˆ¨  - logical or
   Â¬  - logical not
   âˆˆ  - element of (for iteration)
   âŠ¤  - true (top)
   âŠ¥  - false (bottom)
   âˆ…  - empty/never (empty set)

   Composition:
   |> - pipe forward
   >> - compose forward
   << - compose backward
*)

(* ============================================================================ *)
(* EFFECT SYSTEM (Future Extension)                                            *)
(* ============================================================================ *)

(* Functions can be annotated with effects:
   Î»read_file(path:ð•Š)â†’Result[ð•Š,IoError]!IO

   Effect syntax: !EffectName
   Multiple effects: !IO!Async!Network

   Pure functions have no effect annotation (default)
*)

(* ============================================================================ *)
(* EXAMPLES                                                                     *)
(* ============================================================================ *)

(* Example 1: Fibonacci *)
(* Î»fibonacci(n:â„¤)â†’â„¤â‰¡n{0â†’0|1â†’1|nâ†’fibonacci(n-1)+fibonacci(n-2)} *)

(* Example 2: Map function *)
(* Î»map[T,U](fn:Î»(T)â†’U,list:[T])â†’[U]â‰¡list{[]â†’[]|[x,.xs]â†’[fn(x),.map(fn,xs)]} *)

(* Example 3: HTTP handler *)
(* Î»handle(req:Request)â†’Response!Errorâ‰¡req.path{"/users"â†’get_users(req)|"/health"â†’Ok(Response{status:200,body:"OK"})|_â†’Err(Error{code:404,msg:"Not found"})} *)

(* Example 4: Type definitions *)
(* t Option[T]=Some(T)|None *)
(* t Result[T,E]=Ok(T)|Err(E) *)
(* t User={id:â„¤,name:ð•Š,email:ð•Š,active:ð”¹} *)

(* Example 5: Pipeline *)
(* Î»process_users(users:[User])â†’[ð•Š]=users|>filter(Î»uâ†’u.active)|>map(Î»uâ†’u.name) *)

(* ============================================================================ *)
(* END OF GRAMMAR                                                               *)
(* ============================================================================ *)
