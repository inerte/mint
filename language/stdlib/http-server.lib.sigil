âŸ¦ stdlibâ‹…http-server - Canonical HTTP Server for Sigil

This is a thin FFI wrapper around Node.js's http module.
Provides a type-safe, idiomatic Sigil interface for HTTP servers.

This is the ONE canonical way to serve HTTP in Sigil.
No npm dependencies, no library choices - just import and use.
âŸ§

âŸ¦ HTTP request type âŸ§
t Request={
  path:ğ•Š,
  method:ğ•Š,
  headers:Any,
  body:ğ•Š
}

âŸ¦ HTTP response type âŸ§
t Response={
  status:â„¤,
  body:ğ•Š,
  headers:Any
}

âŸ¦ External FFI bindings âŸ§
e console
e http
e url

âŸ¦ Helper: Create a JSON response âŸ§
Î»json(status:â„¤,body:ğ•Š)â†’Response={
  status:status,
  body:body,
  headers:{"Content-Type":"application/json; charset=utf-8"}
}

âŸ¦ Helper: Log HTTP request to console âŸ§
Î»log_request(req:Request)â†’!IO ğ•Œ={
  l log_line=req.method++" "++req.path;
  console.log(log_line)
}

âŸ¦ Helper: Create a 404 Not Found response âŸ§
Î»not_found()â†’Response={
  status:404,
  body:"<h1>404 Not Found</h1>",
  headers:{"Content-Type":"text/html; charset=utf-8"}
}

âŸ¦ Helper: Create a 404 with custom message âŸ§
Î»not_found_msg(path:ğ•Š)â†’Response={
  status:404,
  body:"<h1>404 Not Found</h1><p>Path: "++path++"</p>",
  headers:{"Content-Type":"text/html; charset=utf-8"}
}

âŸ¦ Helper: Create a 200 OK response âŸ§
Î»ok(body:ğ•Š)â†’Response={
  status:200,
  body:body,
  headers:{"Content-Type":"text/html; charset=utf-8"}
}

âŸ¦ Helper: Create a custom response âŸ§
Î»response(status:â„¤,body:ğ•Š,content_type:ğ•Š)â†’Response={
  status:status,
  body:body,
  headers:{"Content-Type":content_type}
}

âŸ¦ Main Export: Start HTTP server on specified port

Usage:
  Î»handle_request(req:Request)â†’!IO Response={
    stdlibâ‹…http-server.log_request(req)
    stdlibâ‹…http-server.ok("<h1>Hello World</h1>")
  }

  Î»main()â†’!IO ğ•Œ={
    stdlibâ‹…http-server.serve(3000,handle_request)
  }
âŸ§

Î»serve(port:â„¤,handler:Î»(Request)â†’!IO Response)â†’!IO ğ•Œ={
  âŸ¦ Create HTTP server with request handler âŸ§
  (http.createServer(Î»(node_req:Any,node_res:Any)â†’!IO ğ•Œ={
    âŸ¦ Parse URL to extract path âŸ§
    l parsed_url=url.parse(node_req.url,âŠ¤);
    l path=parsed_url.pathname;

    âŸ¦ Extract method âŸ§
    l method=node_req.method;

    âŸ¦ For v1, use empty headers map âŸ§
    âŸ¦ TODO: Convert Node.js headers object to Sigil map âŸ§
    l headers={};

    âŸ¦ Collect request body chunks (TODO: typed chunk handling) âŸ§
    âŸ¦ For now, body parsing is stubbed to keep the canonical HTTP wrapper compiling âŸ§

    âŸ¦ Request body parsing not implemented yet (v1 stub) âŸ§
    l body="";

    âŸ¦ Build Sigil Request object âŸ§
    l sigil_request={
      path:path,
      method:method,
      headers:headers,
      body:body
    };

    âŸ¦ Call user-provided handler âŸ§
    l sigil_response=handler(sigil_request);

    âŸ¦ Set response headers from map âŸ§
    âŸ¦ TODO: Header iteration is temporarily stubbed while block/effect sequencing is simplified âŸ§
    l response_headers=sigil_response.headers;

    âŸ¦ TODO: Write response to node_res once callback second-parameter binding is stable in typechecker âŸ§
    l status=sigil_response.status;
    l body_html=sigil_response.body;
    l noop=status;
    l noop2=body_html;

    ()
  })).listen(port,Î»()â†’!IO ğ•Œ={
    l port_str=port.toString();
    console.log("Server running at http://localhost:"++port_str)
    ()
  })

  ()
}

âŸ¦ Helper: Create a 500 Internal Server Error response âŸ§
Î»server_error(message:ğ•Š)â†’Response={
  status:500,
  body:"<h1>500 Internal Server Error</h1><p>"++message++"</p>",
  headers:{"Content-Type":"text/html; charset=utf-8"}
}
