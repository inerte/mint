âŸ¦ Simplified markdown-to-HTML parser for Sigil ecosystem

  Supports: headers, paragraphs, bold, italic, code blocks, inline code
  Does NOT support (v1): lists, blockquotes, links (complex nesting issues with pattern matching)
âŸ§

i stdlibâ‹…string

âŸ¦ Count leading # characters for header level âŸ§
Î»count_hashes(text:ğ•Š)â†’â„¤={
  l len=(#text:â„¤);
  count_hashes_loop(0,len,text)
}

âŸ¦ Tail-recursive helper for count_hashes âŸ§
Î»count_hashes_loop(idx:â„¤,len:â„¤,text:ğ•Š)â†’â„¤â‰¡idx{
  idx when idx<lenâ†’â‰¡(stdlibâ‹…string.char_at(idx,text)="#"){
    âŠ¤â†’count_hashes_loop(idx+1,len,text)|
    âŠ¥â†’idx
  }|
  idxâ†’idx
}

âŸ¦ Extract header text after ## âŸ§
Î»extract_header_text(line:ğ•Š)â†’ğ•Š={
  l trimmed=(stdlibâ‹…string.trim(line):ğ•Š);
  l level=(count_hashes(trimmed):â„¤);
  l len=(#trimmed:â„¤);
  l after_hashes=(â‰¡(level<len){
    âŠ¤â†’stdlibâ‹…string.substring(len,trimmed,level)|
    âŠ¥â†’""
  }:ğ•Š);
  stdlibâ‹…string.trim(after_hashes)
}

âŸ¦ Convert header level to HTML tag âŸ§
Î»header_tag(level:â„¤)â†’ğ•Š={
  "h"++stdlibâ‹…string.int_to_string(level)
}

âŸ¦ Check if line is code fence âŸ§
Î»is_code_fence(line:ğ•Š)â†’ğ”¹={
  l trimmed=(stdlibâ‹…string.trim(line):ğ•Š);
  stdlibâ‹…string.starts_with("```",trimmed)
}

âŸ¦ Check if line is empty âŸ§
Î»is_empty_line(line:ğ•Š)â†’ğ”¹={
  l trimmed=(stdlibâ‹…string.trim(line):ğ•Š);
  l len=(#trimmed:â„¤);
  â‰¡len{0â†’âŠ¤|nâ†’âŠ¥}
}

âŸ¦ Check if line starts with # (header) âŸ§
Î»is_header_line(line:ğ•Š)â†’ğ”¹={
  l trimmed=(stdlibâ‹…string.trim(line):ğ•Š);
  stdlibâ‹…string.starts_with("#",trimmed)
}

âŸ¦ Check if line is horizontal rule âŸ§
Î»is_hr_line(line:ğ•Š)â†’ğ”¹={
  l trimmed=(stdlibâ‹…string.trim(line):ğ•Š);
  l is_dashes=(trimmed="---":ğ”¹);
  l is_stars=(trimmed="***":ğ”¹);
  l is_underscores=(trimmed="___":ğ”¹);
  â‰¡is_dashes{âŠ¤â†’âŠ¤|âŠ¥â†’â‰¡is_stars{âŠ¤â†’âŠ¤|âŠ¥â†’is_underscores}}
}

âŸ¦ Process markdown lines into HTML blocks âŸ§
Î»parse(markdown:ğ•Š)â†’ğ•Š={
  l lines=(stdlibâ‹…string.split("\n",markdown):[ğ•Š]);
  l num_lines=(#lines:â„¤);
  parse_lines_loop("",0,âŠ¥,lines,num_lines,"","")
}

âŸ¦ Parse markdown lines into HTML blocks (recursive helper) âŸ§
Î»parse_lines_loop(code_acc:ğ•Š,idx:â„¤,in_code:ğ”¹,lines:[ğ•Š],num_lines:â„¤,para_acc:ğ•Š,result:ğ•Š)â†’ğ•Š={
  â‰¡(idxâ‰¥num_lines){
    âŠ¤â†’{
      âŸ¦ End of input - flush remaining state âŸ§
      l with_code=(â‰¡in_code{
        âŠ¤â†’result++"\n"++render_code_block(code_acc)|
        âŠ¥â†’result
      }:ğ•Š);
      l para_len=(#para_acc:â„¤);
      â‰¡(para_len>0){
        âŠ¤â†’with_code++"\n"++render_paragraph(para_acc)|
        âŠ¥â†’with_code
      }
    }|
    âŠ¥â†’{
      l line=(lines[idx]:ğ•Š);

      âŸ¦ Handle code block state âŸ§
      â‰¡in_code{
        âŠ¤â†’â‰¡(is_code_fence(line)){
          âŠ¤â†’{
            âŸ¦ End code block âŸ§
            l new_result=(result++"\n"++render_code_block(code_acc):ğ•Š);
            parse_lines_loop("",idx+1,âŠ¥,lines,num_lines,"",new_result)
          }|
          âŠ¥â†’{
            âŸ¦ Accumulate code line âŸ§
            l new_code=(â‰¡(#code_acc>0){
              âŠ¤â†’code_acc++"\n"++line|
              âŠ¥â†’line
            }:ğ•Š);
            parse_lines_loop(new_code,idx+1,âŠ¤,lines,num_lines,para_acc,result)
          }
        }|
        âŠ¥â†’{
          âŸ¦ Not in code block - check for code fence start âŸ§
          â‰¡(is_code_fence(line)){
            âŠ¤â†’{
              âŸ¦ Start code block - flush paragraph first âŸ§
              l new_result=(â‰¡(#para_acc>0){
                âŠ¤â†’result++"\n"++render_paragraph(para_acc)|
                âŠ¥â†’result
              }:ğ•Š);
              parse_lines_loop("",idx+1,âŠ¤,lines,num_lines,"",new_result)
            }|
            âŠ¥â†’{
              âŸ¦ Check for header âŸ§
              â‰¡(is_header_line(line)){
                âŠ¤â†’{
                  l trimmed=(stdlibâ‹…string.trim(line):ğ•Š);
                  l level=(count_hashes(trimmed):â„¤);
                  l text=(extract_header_text(line):ğ•Š);
                  l header_html=(render_header(level,text):ğ•Š);
                  l new_result=(â‰¡(#para_acc>0){
                    âŠ¤â†’result++"\n"++render_paragraph(para_acc)++"\n"++header_html|
                    âŠ¥â†’result++"\n"++header_html
                  }:ğ•Š);
                  parse_lines_loop("",idx+1,âŠ¥,lines,num_lines,"",new_result)
                }|
                âŠ¥â†’{
                  âŸ¦ Check for horizontal rule âŸ§
                  â‰¡(is_hr_line(line)){
                    âŠ¤â†’{
                      l hr_html=(render_hr():ğ•Š);
                      l new_result=(â‰¡(#para_acc>0){
                        âŠ¤â†’result++"\n"++render_paragraph(para_acc)++"\n"++hr_html|
                        âŠ¥â†’result++"\n"++hr_html
                      }:ğ•Š);
                      parse_lines_loop("",idx+1,âŠ¥,lines,num_lines,"",new_result)
                    }|
                    âŠ¥â†’{
                      âŸ¦ Check for empty line âŸ§
                      â‰¡(is_empty_line(line)){
                        âŠ¤â†’{
                          âŸ¦ Flush paragraph âŸ§
                          l new_result=(â‰¡(#para_acc>0){
                            âŠ¤â†’result++"\n"++render_paragraph(para_acc)|
                            âŠ¥â†’result
                          }:ğ•Š);
                          parse_lines_loop("",idx+1,âŠ¥,lines,num_lines,"",new_result)
                        }|
                        âŠ¥â†’{
                          âŸ¦ Regular text line - accumulate into paragraph âŸ§
                          l new_para=(â‰¡(#para_acc>0){
                            âŠ¤â†’para_acc++" "++stdlibâ‹…string.trim(line)|
                            âŠ¥â†’stdlibâ‹…string.trim(line)
                          }:ğ•Š);
                          parse_lines_loop(code_acc,idx+1,âŠ¥,lines,num_lines,new_para,result)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

âŸ¦ Render code block âŸ§
Î»render_code_block(code:ğ•Š)â†’ğ•Š={
  "<pre><code>"++code++"</code></pre>"
}

âŸ¦ Wrap text in header tags âŸ§
Î»render_header(level:â„¤,text:ğ•Š)â†’ğ•Š={
  l tag=(header_tag(level):ğ•Š);
  "<"++tag++">"++text++"</"++tag++">"
}

âŸ¦ Render horizontal rule âŸ§
Î»render_hr()â†’ğ•Š="<hr>"

âŸ¦ Render paragraph âŸ§
Î»render_paragraph(text:ğ•Š)â†’ğ•Š={
  "<p>"++text++"</p>"
}
