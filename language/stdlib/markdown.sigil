âŸ¦ stdlibâ‹…markdown - Pure Sigil Markdown Parser

This is the canonical markdown-to-HTML converter for the Sigil ecosystem.
Implemented entirely in Sigil (no FFI) to demonstrate the language capabilities.

Supported features:
- Headers (# through ######)
- Paragraphs
- Bold (**text**), Italic (*text*)
- Code blocks (```language ... ```)
- Inline code (`code`)
- Links ([text](url))
- Unordered lists (- item)
- Ordered lists (1. item)
- Blockquotes (> text)
- Horizontal rules (---)

Not supported in v1:
- Tables
- Nested blockquotes
- HTML passthrough
- Images (use links for now)
- Complex nesting

This parser uses pattern guards extensively for clean state machine transitions.
âŸ§

i stdlibâ‹…string_ops
i stdlibâ‹…string_predicates

âŸ¦ Parser State âŸ§
t ParseState={
  in_code_block:ğ”¹,
  code_lang:ğ•Š,
  code_lines:[ğ•Š],
  in_list:ğ”¹,
  list_type:ğ•Š,
  list_items:[ğ•Š],
  para_lines:[ğ•Š]
}

âŸ¦ Block Types âŸ§
t Block=Header{level:â„¤,text:ğ•Š}
       |Paragraph{text:ğ•Š}
       |CodeBlock{lang:ğ•Š,code:ğ•Š}
       |UnorderedList{items:[ğ•Š]}
       |OrderedList{items:[ğ•Š]}
       |Blockquote{text:ğ•Š}
       |HorizontalRule

âŸ¦ Initial empty state âŸ§
Î»empty_state()â†’ParseState={
  in_code_block:âŠ¥,
  code_lang:"",
  code_lines:[],
  in_list:âŠ¥,
  list_type:"",
  list_items:[],
  para_lines:[]
}

âŸ¦ Line Type Predicates âŸ§

Î»is_code_fence(line:ğ•Š)â†’ğ”¹=
  stdlibâ‹…string_predicates.starts_with(line,"```")

Î»is_header(line:ğ•Š)â†’ğ”¹=
  stdlibâ‹…string_predicates.starts_with(line,"#")

Î»is_hr(line:ğ•Š)â†’ğ”¹â‰¡line{
  "---" â†’ âŠ¤|
  "***" â†’ âŠ¤|
  "___" â†’ âŠ¤|
  _ â†’ âŠ¥
}

Î»is_unordered_list(line:ğ•Š)â†’ğ”¹=
  stdlibâ‹…string_predicates.starts_with(line,"- ")âˆ¨
  stdlibâ‹…string_predicates.starts_with(line,"* ")âˆ¨
  stdlibâ‹…string_predicates.starts_with(line,"+ ")

Î»is_ordered_list(line:ğ•Š)â†’ğ”¹=
  #line>2âˆ§
  stdlibâ‹…string_predicates.is_digit(stdlibâ‹…string_ops.char_at(line,0))âˆ§
  stdlibâ‹…string_ops.char_at(line,1)="."

Î»is_blockquote(line:ğ•Š)â†’ğ”¹=
  stdlibâ‹…string_predicates.starts_with(line,"> ")

Î»is_empty(line:ğ•Š)â†’ğ”¹=
  stdlibâ‹…string_predicates.is_whitespace(line)

âŸ¦ Extract content from special lines âŸ§

Î»extract_header_level(line:ğ•Š)â†’â„¤â‰¡line{
  l when stdlibâ‹…string_predicates.starts_with(l,"###### ") â†’ 6|
  l when stdlibâ‹…string_predicates.starts_with(l,"##### ") â†’ 5|
  l when stdlibâ‹…string_predicates.starts_with(l,"#### ") â†’ 4|
  l when stdlibâ‹…string_predicates.starts_with(l,"### ") â†’ 3|
  l when stdlibâ‹…string_predicates.starts_with(l,"## ") â†’ 2|
  l when stdlibâ‹…string_predicates.starts_with(l,"# ") â†’ 1|
  _ â†’ 0
}

Î»extract_header_text(line:ğ•Š,level:â„¤)â†’ğ•Š=
  stdlibâ‹…string_ops.substring(line,level+1,#line)

Î»extract_code_lang(line:ğ•Š)â†’ğ•Šâ‰¡#line{
  len when len>3 â†’ stdlibâ‹…string_ops.substring(line,3,len)|
  _ â†’ ""
}

Î»extract_list_item(line:ğ•Š)â†’ğ•Šâ‰¡line{
  l when is_unordered_list(l) â†’ stdlibâ‹…string_ops.substring(l,2,#l)|
  l when is_ordered_list(l) â†’ stdlibâ‹…string_ops.substring(l,3,#l)|
  _ â†’ ""
}

Î»extract_blockquote_text(line:ğ•Š)â†’ğ•Š=
  stdlibâ‹…string_ops.substring(line,2,#line)

âŸ¦ Flush accumulated content to blocks âŸ§

Î»flush_code_block(state:ParseState)â†’[Block]â‰¡state{
  {in_code_block:âŠ¤,code_lang,code_lines,..} â†’
    [CodeBlock{lang:code_lang,code:stdlibâ‹…string_ops.join(code_lines,"\n")}]|
  _ â†’ []
}

Î»flush_list(state:ParseState)â†’[Block]â‰¡state{
  {in_list:âŠ¤,list_type:"ul",list_items,..} â†’ [UnorderedList{items:list_items}]|
  {in_list:âŠ¤,list_type:"ol",list_items,..} â†’ [OrderedList{items:list_items}]|
  _ â†’ []
}

Î»flush_paragraph(state:ParseState)â†’[Block]â‰¡state.para_lines{
  [] â†’ []|
  lines â†’ [Paragraph{text:stdlibâ‹…string_ops.join(lines," ")}]
}

âŸ¦ State Machine - Main Line Parser

This is where pattern guards shine! We match on state structure,
then guard on line content. Clean, linear, readable.
âŸ§

Î»parse_line(state:ParseState,line:ğ•Š)â†’(ParseState,[Block])â‰¡state{
  âŸ¦ Inside code block - check for closing fence âŸ§
  {in_code_block:âŠ¤,..} when is_code_fence(line) â†’
    (empty_state(),flush_code_block(state))|

  âŸ¦ Inside code block - accumulate code lines âŸ§
  {in_code_block:âŠ¤,code_lang,code_lines,..} â†’
    ({in_code_block:âŠ¤,code_lang:code_lang,code_lines:code_linesâ§º[line],
      in_list:âŠ¥,list_type:"",list_items:[],para_lines:[]},[])|

  âŸ¦ Not in code block - check for opening fence âŸ§
  {in_code_block:âŠ¥,in_list,list_type,list_items,..} when is_code_fence(line) â†’
    l lang=extract_code_lang(line);
    l flushed=flush_list(state)â§ºflush_paragraph(state);
    ({in_code_block:âŠ¤,code_lang:lang,code_lines:[],
      in_list:âŠ¥,list_type:"",list_items:[],para_lines:[]},flushed)|

  âŸ¦ Header line âŸ§
  {in_code_block:âŠ¥,..} when is_header(line) â†’
    l level=extract_header_level(line);
    l text=extract_header_text(line,level);
    l flushed=flush_list(state)â§ºflush_paragraph(state);
    (empty_state(),flushedâ§º[Header{level:level,text:text}])|

  âŸ¦ Horizontal rule âŸ§
  {in_code_block:âŠ¥,..} when is_hr(line) â†’
    l flushed=flush_list(state)â§ºflush_paragraph(state);
    (empty_state(),flushedâ§º[HorizontalRule()])|

  âŸ¦ Unordered list item âŸ§
  {in_code_block:âŠ¥,in_list:âŠ¤,list_type:"ul",list_items,..} when is_unordered_list(line) â†’
    l item=extract_list_item(line);
    l flushed=flush_paragraph(state);
    ({in_code_block:âŠ¥,code_lang:"",code_lines:[],
      in_list:âŠ¤,list_type:"ul",list_items:list_itemsâ§º[item],para_lines:[]},flushed)|

  {in_code_block:âŠ¥,in_list:âŠ¥,..} when is_unordered_list(line) â†’
    l item=extract_list_item(line);
    l flushed=flush_paragraph(state);
    ({in_code_block:âŠ¥,code_lang:"",code_lines:[],
      in_list:âŠ¤,list_type:"ul",list_items:[item],para_lines:[]},flushed)|

  âŸ¦ Ordered list item âŸ§
  {in_code_block:âŠ¥,in_list:âŠ¤,list_type:"ol",list_items,..} when is_ordered_list(line) â†’
    l item=extract_list_item(line);
    l flushed=flush_paragraph(state);
    ({in_code_block:âŠ¥,code_lang:"",code_lines:[],
      in_list:âŠ¤,list_type:"ol",list_items:list_itemsâ§º[item],para_lines:[]},flushed)|

  {in_code_block:âŠ¥,in_list:âŠ¥,..} when is_ordered_list(line) â†’
    l item=extract_list_item(line);
    l flushed=flush_paragraph(state);
    ({in_code_block:âŠ¥,code_lang:"",code_lines:[],
      in_list:âŠ¤,list_type:"ol",list_items:[item],para_lines:[]},flushed)|

  âŸ¦ Blockquote âŸ§
  {in_code_block:âŠ¥,..} when is_blockquote(line) â†’
    l text=extract_blockquote_text(line);
    l flushed=flush_list(state)â§ºflush_paragraph(state);
    (empty_state(),flushedâ§º[Blockquote{text:text}])|

  âŸ¦ Empty line - flush paragraph and list âŸ§
  {in_code_block:âŠ¥,..} when is_empty(line) â†’
    l flushed=flush_list(state)â§ºflush_paragraph(state);
    (empty_state(),flushed)|

  âŸ¦ Regular text - accumulate paragraph âŸ§
  {in_code_block:âŠ¥,para_lines,..} â†’
    l flushed=flush_list(state);
    ({in_code_block:âŠ¥,code_lang:"",code_lines:[],
      in_list:âŠ¥,list_type:"",list_items:[],para_lines:para_linesâ§º[line]},flushed)
}

âŸ¦ Parse all lines into blocks âŸ§

Î»parse_lines_helper(state:ParseState,lines:[ğ•Š],blocks:[Block])â†’[Block]â‰¡lines{
  [] â†’
    l final_blocks=flush_code_block(state)â§ºflush_list(state)â§ºflush_paragraph(state);
    blocksâ§ºfinal_blocks|

  [line,.rest] â†’
    l (new_state,new_blocks)=parse_line(state,line);
    parse_lines_helper(new_state,rest,blocksâ§ºnew_blocks)
}

Î»parse_lines(markdown:ğ•Š)â†’[Block]=
  l lines=stdlibâ‹…string_ops.split(markdown,"\n");
  parse_lines_helper(empty_state(),lines,[])

âŸ¦ Inline Element Parsing

Process **bold**, *italic*, `code`, and [links](url) within text.
âŸ§

Î»process_inline_bold(text:ğ•Š)â†’ğ•Š=
  stdlibâ‹…string_ops.replace_all(text,"**","<strong>","</strong>")

Î»process_inline_italic(text:ğ•Š)â†’ğ•Š=
  stdlibâ‹…string_ops.replace_all(text,"*","<em>","</em>")

Î»process_inline_code(text:ğ•Š)â†’ğ•Š=
  stdlibâ‹…string_ops.replace_all(text,"`","<code>","</code>")

âŸ¦ Simplified link processing - find [text](url) patterns âŸ§
Î»process_inline_links(text:ğ•Š)â†’ğ•Š=
  âŸ¦ For v1, just escape and return - proper link parsing is complex âŸ§
  text

Î»process_inline(text:ğ•Š)â†’ğ•Š=
  l step1=process_inline_bold(text);
  l step2=process_inline_italic(step1);
  l step3=process_inline_code(step2);
  process_inline_links(step3)

âŸ¦ Block to HTML Conversion âŸ§

Î»block_to_html(block:Block)â†’ğ•Šâ‰¡block{
  Header{level,text} â†’
    l tag="h"++stdlibâ‹…string_ops.int_to_string(level);
    l processed=process_inline(text);
    "<"++tag++">"++processed++"</"++tag++">"|

  Paragraph{text} â†’
    l processed=process_inline(text);
    "<p>"++processed++"</p>"|

  CodeBlock{lang,code} â†’
    "<pre><code>"++code++"</code></pre>"|

  UnorderedList{items} â†’
    l html_items=itemsâ†¦Î»(item:ğ•Š)â†’ğ•Š="<li>"++process_inline(item)++"</li>";
    l joined=stdlibâ‹…string_ops.join(html_items,"");
    "<ul>"++joined++"</ul>"|

  OrderedList{items} â†’
    l html_items=itemsâ†¦Î»(item:ğ•Š)â†’ğ•Š="<li>"++process_inline(item)++"</li>";
    l joined=stdlibâ‹…string_ops.join(html_items,"");
    "<ol>"++joined++"</ol>"|

  Blockquote{text} â†’
    l processed=process_inline(text);
    "<blockquote>"++processed++"</blockquote>"|

  HorizontalRule â†’
    "<hr>"
}

âŸ¦ Main Export - Parse markdown to HTML âŸ§

export Î»parse(markdown:ğ•Š)â†’ğ•Š=
  l blocks=parse_lines(markdown);
  l html_blocks=blocksâ†¦block_to_html;
  stdlibâ‹…string_ops.join(html_blocks,"\n")
