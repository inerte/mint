âŸ¦ stdlibâ‹…markdown - Pure Sigil Markdown Parser

This is the canonical markdown-to-HTML converter for the Sigil ecosystem.
Implemented entirely in Sigil (no FFI) to demonstrate the language capabilities.

Supported features:
- Headers (# through ######)
- Paragraphs
- Bold (**text**), Italic (*text*)
- Code blocks (```language ... ```)
- Inline code (`code`)
- Links ([text](url))
- Unordered lists (- item)
- Ordered lists (1. item)
- Blockquotes (> text)
- Horizontal rules (---)

Not supported in v1:
- Tables
- Nested blockquotes
- HTML passthrough
- Images (use links for now)
- Complex nesting

This parser uses pattern guards extensively for clean state machine transitions.
âŸ§

i stdlibâ‹…string_ops
i stdlibâ‹…string_predicates

âŸ¦ Block Types âŸ§
t Block=Header(â„¤,ğ•Š)
       |Paragraph(ğ•Š)
       |CodeBlock(ğ•Š,ğ•Š)
       |UnorderedList([ğ•Š])
       |OrderedList([ğ•Š])
       |Blockquote(ğ•Š)
       |HorizontalRule

âŸ¦ Parser State âŸ§
t ParserState={
  in_code_block:ğ”¹,
  code_lang:ğ•Š,
  code_lines:[ğ•Š],
  in_list:ğ”¹,
  list_type:ğ•Š,
  list_items:[ğ•Š],
  para_lines:[ğ•Š]
}

âŸ¦ Parse result - state and blocks âŸ§
t ParsingResult={state:ParserState,blocks:[Block]}

âŸ¦ Block to HTML Conversion âŸ§
Î»block_to_html(block:Block)â†’ğ•Šâ‰¡block{
  Header(level,text) â†’
    l tag="h"++stdlibâ‹…string_ops.int_to_string(level);
    l processed=process_inline(text);
    "<"++tag++">"++processed++"</"++tag++">"|

  Paragraph(text) â†’
    l processed=process_inline(text);
    "<p>"++processed++"</p>"|

  CodeBlock(lang,code) â†’
    "<pre><code>"++code++"</code></pre>"|

  UnorderedList(items) â†’
    l html_items=itemsâ†¦Î»(item:ğ•Š)â†’ğ•Š="<li>"++process_inline(item)++"</li>";
    l joined=stdlibâ‹…string_ops.join(html_items,"");
    "<ul>"++joined++"</ul>"|

  OrderedList(items) â†’
    l html_items=itemsâ†¦Î»(item:ğ•Š)â†’ğ•Š="<li>"++process_inline(item)++"</li>";
    l joined=stdlibâ‹…string_ops.join(html_items,"");
    "<ol>"++joined++"</ol>"|

  Blockquote(text) â†’
    l processed=process_inline(text);
    "<blockquote>"++processed++"</blockquote>"|

  HorizontalRule â†’
    "<hr>"
}

âŸ¦ Empty block list helper âŸ§
Î»empty_blocks()â†’[Block]=[]

âŸ¦ Initial empty state âŸ§
Î»empty_state()â†’ParserState={
  in_code_block:âŠ¥,
  code_lang:"",
  code_lines:[],
  in_list:âŠ¥,
  list_type:"",
  list_items:[],
  para_lines:[]
}

âŸ¦ Extract content from special lines âŸ§
Î»extract_blockquote_text(line:ğ•Š)â†’ğ•Š=
  stdlibâ‹…string_ops.substring(line,2,#line)

Î»extract_code_lang(line:ğ•Š)â†’ğ•Šâ‰¡#line{
  len when len>3 â†’ stdlibâ‹…string_ops.substring(line,3,len)|
  _ â†’ ""
}

Î»extract_header_level(line:ğ•Š)â†’â„¤â‰¡line{
  s when stdlibâ‹…string_predicates.starts_with(s,"###### ") â†’ 6|
  s when stdlibâ‹…string_predicates.starts_with(s,"##### ") â†’ 5|
  s when stdlibâ‹…string_predicates.starts_with(s,"#### ") â†’ 4|
  s when stdlibâ‹…string_predicates.starts_with(s,"### ") â†’ 3|
  s when stdlibâ‹…string_predicates.starts_with(s,"## ") â†’ 2|
  s when stdlibâ‹…string_predicates.starts_with(s,"# ") â†’ 1|
  _ â†’ 0
}

Î»extract_header_text(line:ğ•Š,level:â„¤)â†’ğ•Š=
  stdlibâ‹…string_ops.substring(line,level+1,#line)

Î»extract_list_item(line:ğ•Š)â†’ğ•Šâ‰¡line{
  s when is_unordered_list(s) â†’ stdlibâ‹…string_ops.substring(s,2,#s)|
  s when is_ordered_list(s) â†’ stdlibâ‹…string_ops.substring(s,3,#s)|
  _ â†’ ""
}

âŸ¦ Flush accumulated content to blocks âŸ§
Î»flush_code_block(state:ParserState)â†’[Block]â‰¡state.in_code_block{
  âŠ¤ â†’ [CodeBlock(state.code_lang,stdlibâ‹…string_ops.join(state.code_lines,"\n"))]|
  âŠ¥ â†’ empty_blocks()
}

Î»flush_list(state:ParserState)â†’[Block]â‰¡state.in_list{
  âŠ¥ â†’ empty_blocks()|
  âŠ¤ â†’ flush_list_by_type(state.list_type,state.list_items)
}

Î»flush_list_by_type(list_type:ğ•Š,list_items:[ğ•Š])â†’[Block]â‰¡list_type{
  "ul" â†’ [UnorderedList(list_items)]|
  "ol" â†’ [OrderedList(list_items)]|
  _ â†’ empty_blocks()
}

Î»flush_paragraph(state:ParserState)â†’[Block]â‰¡state.para_lines{
  [] â†’ empty_blocks()|
  lines â†’ [Paragraph(stdlibâ‹…string_ops.join(lines," "))]
}

âŸ¦ Line Type Predicates âŸ§
Î»is_blockquote(line:ğ•Š)â†’ğ”¹=
  stdlibâ‹…string_predicates.starts_with(line,"> ")

Î»is_code_fence(line:ğ•Š)â†’ğ”¹=
  stdlibâ‹…string_predicates.starts_with(line,"```")

Î»is_empty(line:ğ•Š)â†’ğ”¹=
  stdlibâ‹…string_predicates.is_whitespace(line)

Î»is_header(line:ğ•Š)â†’ğ”¹=
  stdlibâ‹…string_predicates.starts_with(line,"#")

Î»is_hr(line:ğ•Š)â†’ğ”¹â‰¡line{
  "---" â†’ âŠ¤|
  "***" â†’ âŠ¤|
  "___" â†’ âŠ¤|
  _ â†’ âŠ¥
}

Î»is_ordered_list(line:ğ•Š)â†’ğ”¹=
  #line>2âˆ§
  stdlibâ‹…string_predicates.is_digit(stdlibâ‹…string_ops.char_at(line,0))âˆ§
  stdlibâ‹…string_ops.char_at(line,1)="."

Î»is_unordered_list(line:ğ•Š)â†’ğ”¹=
  stdlibâ‹…string_predicates.starts_with(line,"- ")âˆ¨
  stdlibâ‹…string_predicates.starts_with(line,"* ")âˆ¨
  stdlibâ‹…string_predicates.starts_with(line,"+ ")

âŸ¦ State Machine - Main Line Parser

Uses field access in pattern guards for the one canonical way to inspect state.
âŸ§
Î»parse_line(state:ParserState,line:ğ•Š)â†’ParsingResultâ‰¡state.in_code_block{
  âŸ¦ Inside code block - check for closing fence âŸ§
  âŠ¤ when is_code_fence(line) â†’
    {state:empty_state(),blocks:flush_code_block(state)}|

  âŸ¦ Inside code block - accumulate code lines âŸ§
  âŠ¤ â†’
    {state:{in_code_block:âŠ¤,code_lang:state.code_lang,code_lines:state.code_linesâ§º[line],
      in_list:âŠ¥,list_type:"",list_items:[],para_lines:[]},blocks:[]}|

  âŸ¦ Not in code block - check for opening fence âŸ§
  âŠ¥ when is_code_fence(line) â†’
    l lang=extract_code_lang(line);
    l flushed=flush_list(state)â§ºflush_paragraph(state);
    {state:{in_code_block:âŠ¤,code_lang:lang,code_lines:[],
      in_list:âŠ¥,list_type:"",list_items:[],para_lines:[]},blocks:flushed}|

  âŸ¦ Header line âŸ§
  âŠ¥ when is_header(line) â†’
    l level=extract_header_level(line);
    l text=extract_header_text(line,level);
    l flushed=flush_list(state)â§ºflush_paragraph(state);
    {state:empty_state(),blocks:flushedâ§º[Header(level,text)]}|

  âŸ¦ Horizontal rule âŸ§
  âŠ¥ when is_hr(line) â†’
    l flushed=flush_list(state)â§ºflush_paragraph(state);
    {state:empty_state(),blocks:flushedâ§º[HorizontalRule()]}|

  âŸ¦ Unordered list item - continuing existing ul âŸ§
  âŠ¥ when state.in_listâˆ§state.list_type="ul"âˆ§is_unordered_list(line) â†’
    l item=extract_list_item(line);
    l flushed=flush_paragraph(state);
    {state:{in_code_block:âŠ¥,code_lang:"",code_lines:[],
      in_list:âŠ¤,list_type:"ul",list_items:state.list_itemsâ§º[item],para_lines:[]},blocks:flushed}|

  âŸ¦ Unordered list item - starting new ul âŸ§
  âŠ¥ when is_unordered_list(line) â†’
    l item=extract_list_item(line);
    l flushed=flush_paragraph(state);
    {state:{in_code_block:âŠ¥,code_lang:"",code_lines:[],
      in_list:âŠ¤,list_type:"ul",list_items:[item],para_lines:[]},blocks:flushed}|

  âŸ¦ Ordered list item - continuing existing ol âŸ§
  âŠ¥ when state.in_listâˆ§state.list_type="ol"âˆ§is_ordered_list(line) â†’
    l item=extract_list_item(line);
    l flushed=flush_paragraph(state);
    {state:{in_code_block:âŠ¥,code_lang:"",code_lines:[],
      in_list:âŠ¤,list_type:"ol",list_items:state.list_itemsâ§º[item],para_lines:[]},blocks:flushed}|

  âŸ¦ Ordered list item - starting new ol âŸ§
  âŠ¥ when is_ordered_list(line) â†’
    l item=extract_list_item(line);
    l flushed=flush_paragraph(state);
    {state:{in_code_block:âŠ¥,code_lang:"",code_lines:[],
      in_list:âŠ¤,list_type:"ol",list_items:[item],para_lines:[]},blocks:flushed}|

  âŸ¦ Blockquote âŸ§
  âŠ¥ when is_blockquote(line) â†’
    l text=extract_blockquote_text(line);
    l flushed=flush_list(state)â§ºflush_paragraph(state);
    {state:empty_state(),blocks:flushedâ§º[Blockquote(text)]}|

  âŸ¦ Empty line - flush paragraph and list âŸ§
  âŠ¥ when is_empty(line) â†’
    l flushed=flush_list(state)â§ºflush_paragraph(state);
    {state:empty_state(),blocks:flushed}|

  âŸ¦ Regular text - accumulate paragraph âŸ§
  âŠ¥ â†’
    l flushed=flush_list(state);
    {state:{in_code_block:âŠ¥,code_lang:"",code_lines:[],
      in_list:âŠ¥,list_type:"",list_items:[],para_lines:state.para_linesâ§º[line]},blocks:flushed}
}

âŸ¦ Parse all lines into blocks âŸ§
Î»parse_lines(markdown:ğ•Š)â†’[Block]=
  l lines=stdlibâ‹…string_ops.split(markdown,"\n");
  parse_lines_helper(empty_state(),lines,[])

Î»parse_lines_helper(state:ParserState,lines:[ğ•Š],blocks:[Block])â†’[Block]â‰¡lines{
  [] â†’
    l final_blocks=flush_code_block(state)â§ºflush_list(state)â§ºflush_paragraph(state);
    blocksâ§ºfinal_blocks|

  [line,.rest] â†’
    l result=parse_line(state,line);
    parse_lines_helper(result.state,rest,blocksâ§ºresult.blocks)
}

âŸ¦ Inline Element Parsing

Process **bold**, *italic*, `code`, and [links](url) within text.
âŸ§
Î»process_inline(text:ğ•Š)â†’ğ•Š=
  l step1=process_inline_bold(text);
  l step2=process_inline_italic(step1);
  l step3=process_inline_code(step2);
  process_inline_links(step3)

Î»process_inline_bold(text:ğ•Š)â†’ğ•Š=
  stdlibâ‹…string_ops.replace_all(text,"**","<strong>","</strong>")

Î»process_inline_code(text:ğ•Š)â†’ğ•Š=
  stdlibâ‹…string_ops.replace_all(text,"`","<code>","</code>")

Î»process_inline_italic(text:ğ•Š)â†’ğ•Š=
  stdlibâ‹…string_ops.replace_all(text,"*","<em>","</em>")

âŸ¦ Simplified link processing - find [text](url) patterns âŸ§
Î»process_inline_links(text:ğ•Š)â†’ğ•Š=
  âŸ¦ For v1, just escape and return - proper link parsing is complex âŸ§
  text

âŸ¦ Main Export - Parse markdown to HTML âŸ§
export Î»parse(markdown:ğ•Š)â†’ğ•Š=
  l blocks=parse_lines(markdown);
  l html_blocks=blocksâ†¦block_to_html;
  stdlibâ‹…string_ops.join(html_blocks,"\n")
