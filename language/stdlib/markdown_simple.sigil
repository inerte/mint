âŸ¦ Simplified markdown-to-HTML parser for Sigil ecosystem

  Supports: headers, paragraphs, bold, italic, code blocks, inline code
  Does NOT support (v1): lists, blockquotes, links (complex nesting issues with pattern matching)
âŸ§

i stdlibâ‹…string
i stdlibâ‹…string

âŸ¦ Check if line starts with # (header) âŸ§
Î»is_header_line(line:ğ•Š)â†’ğ”¹={
  l trimmed=stdlibâ‹…string.trim(line);
  stdlibâ‹…string.starts_with(trimmed,"#")
}

âŸ¦ Check if line is code fence âŸ§
Î»is_code_fence(line:ğ•Š)â†’ğ”¹={
  l trimmed=stdlibâ‹…string.trim(line);
  stdlibâ‹…string.starts_with(trimmed,"```")
}

âŸ¦ Check if line is horizontal rule âŸ§
Î»is_hr_line(line:ğ•Š)â†’ğ”¹={
  l trimmed=stdlibâ‹…string.trim(line);
  l is_dashes=trimmed="---";
  l is_stars=trimmed="***";
  l is_underscores=trimmed="___";
  â‰¡is_dashes{âŠ¤â†’âŠ¤|âŠ¥â†’â‰¡is_stars{âŠ¤â†’âŠ¤|âŠ¥â†’is_underscores}}
}

âŸ¦ Check if line is empty âŸ§
Î»is_empty_line(line:ğ•Š)â†’ğ”¹={
  l trimmed=stdlibâ‹…string.trim(line);
  l len=#trimmed;
  â‰¡len{0â†’âŠ¤|nâ†’âŠ¥}
}

âŸ¦ Count leading # characters for header level âŸ§
Î»count_hashes(text:ğ•Š)â†’â„¤={
  l len=#text;
  l count_loop=Î»(idx:â„¤)â†’â„¤=â‰¡idx{
    idxâ†’â‰¡(idx<len){
      âŠ¤â†’â‰¡(stdlibâ‹…string.char_at(text,idx)="#"){
        âŠ¤â†’count_loop(idxâŠ•1)|
        âŠ¥â†’idx
      }|
      âŠ¥â†’idx
    }
  };
  count_loop(0)
}

âŸ¦ Extract header text after ## âŸ§
Î»extract_header_text(line:ğ•Š)â†’ğ•Š={
  l trimmed=stdlibâ‹…string.trim(line);
  l level=count_hashes(trimmed);
  l len=#trimmed;
  l after_hashes=â‰¡(level<len){
    âŠ¤â†’stdlibâ‹…string.substring(trimmed,level,len)|
    âŠ¥â†’""
  };
  stdlibâ‹…string.trim(after_hashes)
}

âŸ¦ Convert header level to HTML tag âŸ§
Î»header_tag(level:â„¤)â†’ğ•Š={
  "h"âŠ•stdlibâ‹…string.int_to_string(level)
}

âŸ¦ Wrap text in header tags âŸ§
Î»render_header(level:â„¤,text:ğ•Š)â†’ğ•Š={
  l tag=header_tag(level);
  "<"âŠ•tagâŠ•">"âŠ•textâŠ•"</"âŠ•tagâŠ•">"
}

âŸ¦ Render horizontal rule âŸ§
Î»render_hr()â†’ğ•Š="<hr>"

âŸ¦ Render paragraph âŸ§
Î»render_paragraph(text:ğ•Š)â†’ğ•Š={
  "<p>"âŠ•textâŠ•"</p>"
}

âŸ¦ Render code block âŸ§
Î»render_code_block(code:ğ•Š)â†’ğ•Š={
  "<pre><code>"âŠ•codeâŠ•"</code></pre>"
}

âŸ¦ Process markdown lines into HTML blocks âŸ§
export Î»parse(markdown:ğ•Š)â†’ğ•Š={
  l lines=stdlibâ‹…string.split(markdown,"\n");
  l num_lines=#lines;

  âŸ¦ Parse loop - accumulate HTML output âŸ§
  l parse_lines=Î»(idx:â„¤,result:ğ•Š,in_code:ğ”¹,code_acc:ğ•Š,para_acc:ğ•Š)â†’ğ•Š=â‰¡(idxâ‰¥num_lines){
    âŠ¤â†’{
      âŸ¦ End of input - flush remaining state âŸ§
      l with_code=â‰¡in_code{
        âŠ¤â†’resultâŠ•"\n"âŠ•render_code_block(code_acc)|
        âŠ¥â†’result
      };
      l para_len=#para_acc;
      â‰¡(para_len>0){
        âŠ¤â†’with_codeâŠ•"\n"âŠ•render_paragraph(para_acc)|
        âŠ¥â†’with_code
      }
    }|
    âŠ¥â†’{
      l line=lines[idx];

      âŸ¦ Handle code block state âŸ§
      â‰¡in_code{
        âŠ¤â†’â‰¡(is_code_fence(line)){
          âŠ¤â†’{
            âŸ¦ End code block âŸ§
            l new_result=resultâŠ•"\n"âŠ•render_code_block(code_acc);
            parse_lines(idxâŠ•1,new_result,âŠ¥,"","")
          }|
          âŠ¥â†’{
            âŸ¦ Accumulate code line âŸ§
            l new_code=â‰¡(#code_acc>0){
              âŠ¤â†’code_accâŠ•"\n"âŠ•line|
              âŠ¥â†’line
            };
            parse_lines(idxâŠ•1,result,âŠ¤,new_code,para_acc)
          }
        }|
        âŠ¥â†’{
          âŸ¦ Not in code block - check for code fence start âŸ§
          â‰¡(is_code_fence(line)){
            âŠ¤â†’{
              âŸ¦ Start code block - flush paragraph first âŸ§
              l new_result=â‰¡(#para_acc>0){
                âŠ¤â†’resultâŠ•"\n"âŠ•render_paragraph(para_acc)|
                âŠ¥â†’result
              };
              parse_lines(idxâŠ•1,new_result,âŠ¤,"","")
            }|
            âŠ¥â†’{
              âŸ¦ Check for header âŸ§
              â‰¡(is_header_line(line)){
                âŠ¤â†’{
                  l trimmed=stdlibâ‹…string.trim(line);
                  l level=count_hashes(trimmed);
                  l text=extract_header_text(line);
                  l header_html=render_header(level,text);
                  l new_result=â‰¡(#para_acc>0){
                    âŠ¤â†’resultâŠ•"\n"âŠ•render_paragraph(para_acc)âŠ•"\n"âŠ•header_html|
                    âŠ¥â†’resultâŠ•"\n"âŠ•header_html
                  };
                  parse_lines(idxâŠ•1,new_result,âŠ¥,"","")
                }|
                âŠ¥â†’{
                  âŸ¦ Check for horizontal rule âŸ§
                  â‰¡(is_hr_line(line)){
                    âŠ¤â†’{
                      l hr_html=render_hr();
                      l new_result=â‰¡(#para_acc>0){
                        âŠ¤â†’resultâŠ•"\n"âŠ•render_paragraph(para_acc)âŠ•"\n"âŠ•hr_html|
                        âŠ¥â†’resultâŠ•"\n"âŠ•hr_html
                      };
                      parse_lines(idxâŠ•1,new_result,âŠ¥,"","")
                    }|
                    âŠ¥â†’{
                      âŸ¦ Check for empty line âŸ§
                      â‰¡(is_empty_line(line)){
                        âŠ¤â†’{
                          âŸ¦ Flush paragraph âŸ§
                          l new_result=â‰¡(#para_acc>0){
                            âŠ¤â†’resultâŠ•"\n"âŠ•render_paragraph(para_acc)|
                            âŠ¥â†’result
                          };
                          parse_lines(idxâŠ•1,new_result,âŠ¥,"","")
                        }|
                        âŠ¥â†’{
                          âŸ¦ Regular text line - accumulate into paragraph âŸ§
                          l new_para=â‰¡(#para_acc>0){
                            âŠ¤â†’para_accâŠ•" "âŠ•stdlibâ‹…string.trim(line)|
                            âŠ¥â†’stdlibâ‹…string.trim(line)
                          };
                          parse_lines(idxâŠ•1,result,âŠ¥,code_acc,new_para)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  parse_lines(0,"",âŠ¥,"","")
}
