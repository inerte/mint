âŸ¦ Seeded ASCII dungeon generator (pure Sigil, no mutable grid).

   Research constraints:
   - RNG is explicit state threaded through functions
   - rooms are generated inside non-overlapping zones (no retry loops)
   - rendering is tileAt(world,x,y) + recursive string building
âŸ§

e console

c width:â„¤=48
c height:â„¤=18
c seed0:â„¤=1337

t Rng={seed:â„¤}
t IntRoll={rng:Rng,value:â„¤}
t Room={x:â„¤,y:â„¤,w:â„¤,h:â„¤}
t RoomRoll={rng:Rng,room:Room}
t World={room1:Room,room2:Room,room3:Room}

Î»nextRng(rng:Rng)â†’Rng=
  Rng{seed:((rng.seed*48271)%2147483647)}

Î»randInt(rng:Rng,min:â„¤,max:â„¤)â†’IntRoll={
  l next=nextRng(rng);
  l span=(max-min)+1;
  l value=min+(next.seed%span);
  IntRoll{rng:next,value:value}
}

Î»randRoomInZone(rng:Rng,zx:â„¤,zy:â„¤,zw:â„¤,zh:â„¤)â†’RoomRoll={
  l wRoll=randInt(rng,5,zw-1);
  l hRoll=randInt(wRoll.rng,4,zh-1);
  l xRoll=randInt(hRoll.rng,zx,(zx+zw)-wRoll.value);
  l yRoll=randInt(xRoll.rng,zy,(zy+zh)-hRoll.value);
  l room=Room{x:xRoll.value,y:yRoll.value,w:wRoll.value,h:hRoll.value};
  RoomRoll{rng:yRoll.rng,room:room}
}

Î»makeWorld(seed:â„¤)â†’World={
  l rng=Rng{seed:seed};
  l r1=randRoomInZone(rng,2,2,13,6);
  l r2=randRoomInZone(r1.rng,18,2,14,7);
  l r3=randRoomInZone(r2.rng,32,9,12,6);
  World{room1:r1.room,room2:r2.room,room3:r3.room}
}

Î»halfFloor(n:â„¤)â†’â„¤â‰¡n{
  0â†’0|
  1â†’0|
  nâ†’1+halfFloor(n-2)
}

Î»centerX(room:Room)â†’â„¤=room.x+halfFloor(room.w)
Î»centerY(room:Room)â†’â„¤=room.y+halfFloor(room.h)

Î»min2(a:â„¤,b:â„¤)â†’â„¤â‰¡a<b{
  âŠ¤â†’a|
  _â†’b
}

Î»max2(a:â„¤,b:â„¤)â†’â„¤â‰¡a>b{
  âŠ¤â†’a|
  _â†’b
}

Î»inRect(x:â„¤,y:â„¤,rx:â„¤,ry:â„¤,rw:â„¤,rh:â„¤)â†’ğ”¹=((xâ‰¥rx)âˆ§(x<rx+rw))âˆ§((yâ‰¥ry)âˆ§(y<ry+rh))
Î»inRoom(x:â„¤,y:â„¤,room:Room)â†’ğ”¹=inRect(x,y,room.x,room.y,room.w,room.h)
Î»inH(x:â„¤,y:â„¤,x1:â„¤,x2:â„¤,cy:â„¤)â†’ğ”¹=((y=cy)âˆ§(xâ‰¥min2(x1,x2)))âˆ§(xâ‰¤max2(x1,x2))
Î»inV(x:â„¤,y:â„¤,cx:â„¤,y1:â„¤,y2:â„¤)â†’ğ”¹=((x=cx)âˆ§(yâ‰¥min2(y1,y2)))âˆ§(yâ‰¤max2(y1,y2))

Î»corridorL(x:â„¤,y:â„¤,a:Room,b:Room)â†’ğ”¹=
  inH(x,y,centerX(a),centerX(b),centerY(a))âˆ¨
  inV(x,y,centerX(b),centerY(a),centerY(b))

Î»isFloor(world:World,x:â„¤,y:â„¤)â†’ğ”¹=
  inRoom(x,y,world.room1)âˆ¨
  inRoom(x,y,world.room2)âˆ¨
  inRoom(x,y,world.room3)âˆ¨
  corridorL(x,y,world.room1,world.room2)âˆ¨
  corridorL(x,y,world.room2,world.room3)

Î»isPlayer(world:World,x:â„¤,y:â„¤)â†’ğ”¹=(x=centerX(world.room1))âˆ§(y=centerY(world.room1))
Î»isExit(world:World,x:â„¤,y:â„¤)â†’ğ”¹=(x=centerX(world.room3))âˆ§(y=centerY(world.room3))

Î»tileAt(world:World,x:â„¤,y:â„¤)â†’ğ•Šâ‰¡isPlayer(world,x,y){
  âŠ¤â†’"@"|
  _â†’â‰¡isExit(world,x,y){
    âŠ¤â†’">"|
    _â†’â‰¡isFloor(world,x,y){
      âŠ¤â†’"."|
      _â†’"#"
    }
  }
}

Î»renderRow(world:World,y:â„¤,x:â„¤)â†’ğ•Šâ‰¡width-x{
  0â†’""|
  _â†’tileAt(world,x,y)++renderRow(world,y,x+1)
}

Î»renderRows(world:World,y:â„¤)â†’ğ•Šâ‰¡height-y{
  0â†’""|
  _â†’renderRow(world,y,0)++"\n"++renderRows(world,y+1)
}

Î»main()â†’!IO ğ•Œ={
  l world=makeWorld(seed0);
  console.log(renderRows(world,0))
}
